# MSA 1 일차 - MSA 
## 계층이 4개.
1. 가장 아래 – cloud PaaS 계층. 이게 없으면 MSA 안된다
(고객 마음이 was 배포로 바뀔수 있으니 따로 또 같이 배포가능해야 한다.)
2. CI/CD – 빌드 배포
3. MSA – 서비스가 서비스를 어떻게 찾는지 협업에 관한 이야기. 마이크로 서비스들간 협업 어떻게 하냐. 여기서 넷플릭스 이야기 나온다. 어떻게 처리를 할거냐. 
4. 서비스자체. 서비스 하나하나 – 서비스 하나가 잘 구조화 되어야 한다. 서비스가 well-organize되어야 함
--> 여기에 핵심.기술 셋 변화에 상관없이 내 도메인에 관한 로직은 지켜져야 한다.

## 프로젝트 가자마자 개발 시작
1. 요구사항이 나오지 않아도 미리 정해져있는 내용 기준으로 개발을 빨리빨리 시작되어야 한다.
2. 독립적으로 되어 있기 때문에 다른 업무가 정해지지 않아도 개발 가능 -> 0.1 버전으로 빨리 개발 시작해야함.
3. 화면 검증도 고객과 함께 빨리 개발 시작해야함.

## 기업 IT 운영의 3대 과제
1. 장애
2. 성능 저하
3. 변경 지연
-> 소프트웨어 설계대로 진행했으면 발생하지 않았을 문제들.
-> 이런 문제들이 발생하지 않도록 기술적인 부분도 많이 발전됨.

1. 장애
    - 프로그램 오류
    - 자원 한계 도달 : 주로 DB에서 발생하는 문제. ex)라이나 생명 - 급격한 비즈니스 확장으로 고객 정보 띄우는데 10초가 걸림. 일주일에 한번정도는 시스템 다운됨. WAS 5대인데 1대가 다운되서 시스템 다운.
    - 등등...
  -> 장애해결하면 복잡도는 계속 증가됨

2. 성능저하
    - 데이터양 : 통합 디비시 500기가 넘어가면 굉장히 힘들어함. e-commerce는 상품이 4천개가 넘음. 500기가 넘어가면 디비에서 감당이 안됨.
    - 특정자원으로 처리 집중 : 룰엔진같은 경우 업무 집중됨
    - 보안요구 : 전체가 다운되버림
  -> 장애 해결후 복잡도 증가됨

3. 변경지연
    - 업무 복잡도가 증가 -> 구조변화에 대응못함 -> 사람을 더 투입함... 
    -> 복잡도 증가
  
    => 결국 이러다가 차세대가 열림.
    
## 복잡도
1. 재사용성
    - 2000년대 이후 사라짐. 복잡도를 높히는 원인이 됨 (데이터 복제, 코드 중복이 권고)
2. 구조적인 대응
    - 조직이 커질때 조직 하나 자체가 커지는게 아니라 또다른 조직이 생기는 방향으로 변화함. 소프트웨어도 마찬가지도 대응해야 함(ebay)

## 모델링 기술 흐름
1. OOAD -> CBD -> SOA -> MSA
2. 마틴파울러 : 컴포넌트의 이상이 실현되었다.(컴포넌트별 독립적인 배포)
3. 도메인은 로직이 아니고 컨셉. 엔터티는 인포메이션 홀더. 로직개체들은 엔터티들도 뭔가 하는 애들. 인터페이스가 외부에 정의됨
4. 비즈니스는 바뀌지 않는다. 추가되는 비즈니스만 있을 뿐. (기술은 계속 변화)
5. 서비스
    - MSA에서 디비만큼 중요한게 큐. (동기화 문제 데이터 공유 문제.) -> 데이터 레이어라기 보다는 리소스 레이어로 표현
    - 웹은 RESTful API 만 인정
    - 트랜잭션은 관계형디비가 걸어주는 기술. 플랫폼서비스객체(EJB같은) 여기서 트랜잭션 걸어줌
6. 연결기술
    - EAI -> ESB -> API Gateway
    - EAI가 있으면 옛날 시스템이라고 볼 수 있다.
    - 전송방식과 메시지 포맷변화 : 고정길이전문(TCP) -> xml(HTTP) -> JSON(HTTP.REST) -> AVRO(HTTP.REST). KAFKA
    - 카프카 엄청 중요.
    - 객체로부터 서비스까지.
    사무실에서 일을한다?

객체지향 | CBD | SOA | MSA
------- | ------- | ------- | -------
직원들이 어딘가에서 알아서 일을 한다. 문제 : 객체는 생각보다 작다.객체 하나로 표현할 수 있는게 없어서 객체 여러개가 일을 같이 해야 하는데 너무 복잡해짐 |  비슷한일 하는 객체들끼리 묶어버림 (컴포넌트). 직원들을 팀으로 묶어버림 문제 : 직접 가서 이야기를 해야함. 소통이 힘듬. 인터페이스가 대면 인터페이스만 있음 | 전화기를 팀별로 놔줌. 직접 가지 않아도 소통할 수 있도록 -> 이게 서비스(HTTP기반 rest OR 웹서비스) 문제 : 회사가 커져서 지역이 멀어짐. 소통이 힘듬 | 지역별로 영업소를 내줌. 전부 RESTful 로 통신. 니즈가 발생하는 곳에 빨리 사무실을 내줘야 함. 


## why MSA?
1. MSA 테이블 3개~4개 정도. 10개도 많다.
2. 테이블 속에 관계라는 개념이 없다.
3. 카산드라디비는 네트워크만 되면 확장이 무제한됨. -> MSA에서 뜨고 있다.
4. CQRS
        - T World : 요금제바꾸는 사람은 1% 나머지는 다 조회성.
        - immutable data 는 막 복제해도 됨. 어차피 변경이 안되므로. value-object 같은거
        - 미리 조회할 케이스에 대해 데이터를 다 만들어놓음. 전달 기록 같은거. 어차피 immuatalbe이라서 복제 막 해도 됨.
        - 월말에 READ data 의 인스턴스를 많이 늘림. 월말에 많이 조회하므로.
        - eventual consistency 임. 일시적으로 consistency가 깨짐. (SAGA 패턴)
        - 상태를 이용해서 A->B->C 가 다완료되면 다 상태값 완료로 바꿔줌.
        - 혹은 보상 트랜잭션을 이용하여 최종 일관성 유지
5. 새로운 멤버가 왔을 때 바로 다음날부터 개발을 시작할 수 있는가 도 중요한 MSA 기준
6. FrontEnd BackEnd 를 나눠서 개발하면 러닝커브가 줄어들어서 더 빨리 개발이 가능
