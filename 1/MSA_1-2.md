## 1일차 - MSA시작
# 웹 아키텍처 발전
1. 웹아키텍처 - 컨텐츠를 말아서 보내다가 너무 느려서 서버사이드에서 javascript로 데이터를 렌더링함
2. 서비스아키텍처 - 클라이언트단 HTML파일에서 데이터를 렌더링함
3. 마이크로서비스 아키텍처 
  - 모든 마이크로서비스는 UI를 가지고 있다. *(너무 웹에 한정된 이야기인듯..)*
  - 서비스간 호출 규칙을 명확히 해야함.

# NoSQL - 스키마 없음.
1. 버전이 계속 올라가는데 스키마를 가지고 있으면 안된다. -> NoSQL
2. 데이터 확장이 쉽다. 무한 확장 가능
3. DB에 대한 역할 변화가 일어남 -> DBMS에서 Store가 됨. Manangement를 비즈니스 로직 레이어에서 해결
4. 전에는 시스템의 주인이 DB였고 우리는 단순히 그걸 visualizaiton해주는 wrapper 정도만 만든거였다.
-> ELK 스택으로 해결가능


# Elastic Search 사례
1. 기존에 개발자들은 서버에 telnet으로 접속 로그 파일을 찾아서 로그 확임
2. 로깅구조 - 클라이언트에 로그 걸고, 서버 사이드, 쿼리에 로그 건다.
3. 계속 로그를 던지면 필요한 문자를 찾아 Logstash에게 던지면 ElasticSearch에 들어가고 Kibana로 확인가능
4. 대시보드 - PMO 뷰(퍼포먼스 그래프 확인가능), PL뷰(어떤 업무가 가장 느린지 워드프레스 형태도 확인가능), 개발자뷰(로그, 쿼리 다 확인가능)
5. 저런 대시보드 만드는데 일주일도 안걸림. 아주 쉽게 구성 가능
6. 개별 PC 매트릭뷰도 가능(특정 고객이 너무 느리다고 할 경우 개인 PC 점검 가능)
-> 예전엔 이런걸 다 DBMS가 했었음

# 트랜잭션 - ACID에서 BASE로
1. 가용성(Availability)이 가장 중요함. (전에는 consistency가 가장 중요했음).
   요새는 리퀘스트가 너무 많기 때문에(트래픽양이 너무 많아서) 가용성이 중요.
2. Soft-State : All or Nothing이 아니라 곧 그렇게 될거야 라는 상태.(consistency가 일시적으로 깨진 상태)
3. Consistency가 깨지는 주기는 아주 상대적임.
  - 요새는 1초가 억겁의 시간. 그래서 요새는 밀리세컨 기준임. 점점 깨지는 시간은 줄어들고 있음.
  - 공장에서는 consistency가 깨지면 난리남. 하지만 밀리세컨 기준이기 때문에 크게 문제 없음. 3밀리~5밀리 세컨. 사람이 인지할 수 없음.
4 트랜잭션을 BASE 트랜잭션이라고 프로젝트 초반에 명확히 정의하고 가야한다.
  - ACID도 요새 2.0으로 정의해서 BASE 기반으로 가려는 트렌드를 막으려고 하는 중이다.
  - 쓰기는 차단하지 않는다.(가용성이 좋다.)
  - 일치성이아니라 처리에 초점을 둔다.
  - 무조건 쓰기만 하는 디비가 생김 -> 카산드라 디비(업데이트라는 개념이 없다.)
    -> 이벤트 소싱. (원하는 시점에 이벤트의 스냅샷을 확인)
  - consistency가 깨지면 하나의 리퀘스트에 넣으면 되기 때문에 큰 문제 되지 않는다.

# 현대의 엔터프라이즈 아키텍처
1. 람다스타일
  * 온라인 처리영역 : 비즈니스 로직 자체에 집중. 자기 고유의 업에 집중. 관련되는 다른 부분은 메세지로 흘림
  * Reactive 처리영역 : 카트에 넣어두면 얼마 후 쿠폰을 발행해줌. 데이터를 Summary함. 자기 디비가 없으므로 큐에 흘림
  * BigData 처리영역 : 저수지. 모든 데이터는 다 여기로 흘려들어옴. 데이터 중복이라고 생각하면 안됨. 분석하는 메커니즘. ELK 스택
2. 서비스 협업
  * 각각 서비스를 분리
  * CQRS 적용 - Scaillable한 서비스를 위하여. CUD와 R서비스의 인스턴스 증가 속도가 다름

# 분산 스트림 플랫폼 - 카프카
1. 카프카의 원래 용도 흘러가는 메세지를 잡아서 재처리하는 용도 + 메세지 큐의 기능
2. 전통적인 메세지 큐와 달리 카프카는 실시간처리
3. 카프카를 바닥에 깔아두면 카프카를 통해 모든게 수집되고 전달 될 수 있다.
4. 의료에서 연구 조직의 경우 기존에는 배치로 가져왔는데 이제 카프카를 통해 실시간으로 바로 데이터를 가져올 수 있다.
5. 메세지 큐들이 이걸 흉내내려고 하는데 안된다. 
6. 분산하고 리얼타임으로 데이터 분배는 주키퍼가 내부적으로 해줌.
7. 순서도 조정가능함. 동일한 파티션으로 보내면 동일한 순서로 처리해줌.

