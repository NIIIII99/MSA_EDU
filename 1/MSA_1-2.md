## 1일차 - MSA시작
# 웹 아키텍처 발전
1. 웹아키텍처 - 컨텐츠를 말아서 보내다가 너무 느려서 서버사이드에서 javascript로 데이터를 렌더링함
2. 서비스아키텍처 - 클라이언트단 HTML파일에서 데이터를 렌더링함
3. 마이크로서비스 아키텍처 
  - 모든 마이크로서비스는 UI를 가지고 있다. *(너무 웹에 한정된 이야기인듯..)*
  - 서비스간 호출 규칙을 명확히 해야함.

# NoSQL - 스키마 없음.
1. 버전이 계속 올라가는데 스키마를 가지고 있으면 안된다. -> NoSQL
2. 데이터 확장이 쉽다. 무한 확장 가능
3. DB에 대한 역할 변화가 일어남 -> DBMS에서 Store가 됨. Manangement를 비즈니스 로직 레이어에서 해결
4. 전에는 시스템의 주인이 DB였고 우리는 단순히 그걸 visualizaiton해주는 wrapper 정도만 만든거였다.
-> ELK 스택으로 해결가능


# Elastic Search 사례
1. 기존에 개발자들은 서버에 telnet으로 접속 로그 파일을 찾아서 로그 확임
2. 로깅구조 - 클라이언트에 로그 걸고, 서버 사이드, 쿼리에 로그 건다.
3. 계속 로그를 던지면 필요한 문자를 찾아 Logstash에게 던지면 ElasticSearch에 들어가고 Kibana로 확인가능
4. 대시보드 - PMO 뷰(퍼포먼스 그래프 확인가능), PL뷰(어떤 업무가 가장 느린지 워드프레스 형태도 확인가능), 개발자뷰(로그, 쿼리 다 확인가능)
5. 저런 대시보드 만드는데 일주일도 안걸림. 아주 쉽게 구성 가능
6. 개별 PC 매트릭뷰도 가능(특정 고객이 너무 느리다고 할 경우 개인 PC 점검 가능)
-> 예전엔 이런걸 다 DBMS가 했었음

# 트랜잭션 - ACID에서 BASE로
1. 가용성(Availability)이 가장 중요함. (전에는 consistency가 가장 중요했음).
   요새는 리퀘스트가 너무 많기 때문에(트래픽양이 너무 많아서) 가용성이 중요.
2. Soft-State : All or Nothing이 아니라 곧 그렇게 될거야 라는 상태.(consistency가 일시적으로 깨진 상태)
3. Consistency가 깨지는 주기는 아주 상대적임.
  - 요새는 1초가 억겁의 시간. 그래서 요새는 밀리세컨 기준임. 점점 깨지는 시간은 줄어들고 있음.
  - 공장에서는 consistency가 깨지면 난리남. 하지만 밀리세컨 기준이기 때문에 크게 문제 없음. 3밀리~5밀리 세컨. 사람이 인지할 수 없음.
4 트랜잭션을 BASE 트랜잭션이라고 프로젝트 초반에 명확히 정의하고 가야한다.
  - ACID도 요새 2.0으로 정의해서 BASE 기반으로 가려는 트렌드를 막으려고 하는 중이다.
  - 쓰기는 차단하지 않는다.(가용성이 좋다.)
  - 일치성이아니라 처리에 초점을 둔다.
  - 무조건 쓰기만 하는 디비가 생김 -> 카산드라 디비(업데이트라는 개념이 없다.)
    -> 이벤트 소싱. (원하는 시점에 이벤트의 스냅샷을 확인)
  - consistency가 깨지면 하나의 리퀘스트에 넣으면 되기 때문에 큰 문제 되지 않는다.

# 람다 
